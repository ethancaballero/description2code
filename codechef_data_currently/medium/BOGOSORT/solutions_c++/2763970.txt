#include <cstdio>
#include <iostream>
#include <fstream>
#include <sstream>
#include <set>
#include <map>
#include <vector>
#include <list>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#include <queue>
#include <bitset>		
#include <cassert>
#include <iomanip>	
using namespace std;
#define PB push_back
#define LL long long
#define ULL unsigned LL
#define LD long double
 
 
namespace arith {
 
typedef unsigned int uint;
typedef unsigned long long ull;
 
const int LOGBASE = sizeof(uint)*8;
const ull BASE = 1ULL<<LOGBASE;
 
inline void assert_msg(bool cond, const std::string& msg) {
    if (!cond) { std::cerr << "arith: " << msg << std::endl; exit(1); }
}
 
inline void strip(std::vector<uint>& r, int pos=0) {
    while (r.size()>pos && !r.back()) r.pop_back();
}
 
inline void add(const std::vector<uint>& x, ull s, std::vector<uint>& r) {
    r.resize(x.size());
    for (int i=0; i<x.size(); ++i) { s += x[i]; r[i] = s; s >>= LOGBASE; }
    if (s) r.push_back(s);
}
 
inline void add(const std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r) {
    r.resize(std::max(x.size(), y.size())); ull s=0; int i=0;
    for (; i<x.size() && i<y.size(); ++i) { s += x[i]; s += y[i]; r[i] = s; s >>= LOGBASE; }
    for (; i<x.size(); ++i) { s += x[i]; r[i] = s; s >>= LOGBASE; }
    for (; i<y.size(); ++i) { s += y[i]; r[i] = s; s >>= LOGBASE; }
    if (s) r.push_back(s);
}
 
template<class Iter1, class Iter2>
inline int cmp(Iter1 b1, Iter2 e1, Iter1 b2, Iter2 e2) {
    if (e1-b1!=e2-b2) return e1-b1<e2-b2 ? -1 : 1;
    while (e1!=b1) if (*--e1 != *--e2) return *e1<*e2 ? -1 : 1;
    return 0;
}
 
inline void sub(const std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r, int pos=0) {
    int old_pos=pos; r.resize(x.size()); ull s=1;
    for (int i=0; i<y.size(); ++i, ++pos) { s += x[pos]; s += (BASE-1)-y[i]; r[pos] = s; s >>= LOGBASE; }
    if (!s) {
        for (; !x[pos]; ++pos) r[pos] = BASE-1;
        r[pos] = x[pos]-1; ++pos;
    }
    for (; pos<x.size(); ++pos) r[pos] = x[pos];
    strip(r, old_pos);
}
 
inline void mul(const std::vector<uint>& x, uint v, std::vector<uint>& r) {
    r.resize(x.size()); ull s=0;
    for (int i=0; i<x.size(); ++i) { s += 1ULL*v*x[i]; r[i] = s; s >>= LOGBASE; }
    if (s) r.push_back(s);
    strip(r);
}
 
inline void muladd(const std::vector<uint>& x, uint v, std::vector<uint>& r, int pos) {
    ull s=0;
    for (int i=0; i<x.size(); ++i, ++pos) { s += 1ULL*v*x[i] + r[pos]; r[pos] = s; s >>= LOGBASE; }
    for (; s && pos<r.size(); ++pos) { s += r[pos]; r[pos] = s; s >>= LOGBASE; }
    if (s) r.push_back(s);
}
 
inline void mul(const std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r) {
    if (x.empty() || y.empty()) return;
    r.resize(x.size()+y.size()-1);
    for (int i=x.size()-1; i>=0; --i) muladd(y, x[i], r, i);
    strip(r);
}
 
inline uint div(const std::vector<uint>& x, uint d, std::vector<uint>& r) {
    r.resize(x.size()); uint q=0;
    for (int i=x.size()-1; i>=0; --i) { ull t = BASE*q + x[i]; r[i] = t/d; q = t%d; }
    strip(r);
    return q;
}
 
inline void div(std::vector<uint>& x, const std::vector<uint>& y, std::vector<uint>& r) {
    if (x.size()<y.size()) return;
    int pos = x.size()-y.size(); r.resize(pos+1);
    std::vector<uint> buf;
    do {
        uint q=0;
        for (uint m=1U<<LOGBASE-1; m; m>>=1) {
            mul(y, q|m, buf);
            if (cmp(buf.begin(), buf.end(), x.begin()+pos, x.end()) <= 0) q|=m;
        }
        r[pos] = q; mul(y, q, buf);
        sub(x, buf, x, pos);
    } while (pos--);
    strip(r);
}
 
} // namespace arith
 
//using namespace arith;
 
class biguint {
    std::vector<uint> buf;
    
public:
    biguint() {}
    biguint(int x) {        
        if (x) buf.push_back(x);
    }
    biguint(unsigned int x) {
        if (x) buf.push_back(x);
    }
    biguint(long long x) {        
        if (x) buf.push_back(x);
        if (x>>arith::LOGBASE) buf.push_back(x>>arith::LOGBASE);
    }
    biguint(unsigned long long x) {
        if (x) buf.push_back(x);
        if (x>>arith::LOGBASE) buf.push_back(x>>arith::LOGBASE);
    }
    
    biguint& operator+=(const biguint& y) {
        arith::add(buf, y.buf, buf);
        return *this;
    }
    biguint& operator-=(const biguint& y) {        
        arith::sub(buf, y.buf, buf);
        return *this;
    }
    biguint& operator*=(const biguint& y) {
        std::vector<uint> tmp;
        arith::mul(buf, y.buf, tmp);
        buf = tmp;
        return *this;
    }
    biguint& operator/=(const biguint& y) {        
        std::vector<uint> tmp;
        arith::div(buf, y.buf, tmp);
        buf = tmp;
        return *this;
    }
    biguint& operator%=(const biguint& y) {        
        std::vector<uint> tmp;
        arith::div(buf, y.buf, tmp);
        return *this;
    }
    
    friend biguint operator+(const biguint& x, const biguint& y) {
        biguint z;
        arith::add(x.buf, y.buf, z.buf);
        return z;
    }
    friend biguint operator-(const biguint& x, const biguint& y) {        
        biguint z;
        arith::sub(x.buf, y.buf, z.buf);
        return z;
    }
    friend biguint operator*(const biguint& x, const biguint& y) {
        biguint z;
        arith::mul(x.buf, y.buf, z.buf);
        return z;
    }
    friend biguint operator/(const biguint& x, const biguint& y) {        
        std::vector<uint> tmp(x.buf); biguint z;
        arith::div(tmp, y.buf, z.buf);
        return z;
    }
    friend biguint operator%(const biguint& x, const biguint& y) {        
        biguint z(x); std::vector<uint> tmp;
        arith::div(z.buf, y.buf, tmp);
        return z;
    }    
    bool operator!() const { return buf.empty(); }
    
    friend bool operator==(const biguint& x, const biguint& y) {
        return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) == 0;
    }
    friend bool operator!=(const biguint& x, const biguint& y) {
        return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) != 0;
    }
    friend bool operator<(const biguint& x, const biguint& y) {
        return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) < 0;
    }
    friend bool operator<=(const biguint& x, const biguint& y) {
        return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) <= 0;
    }
    friend bool operator>(const biguint& x, const biguint& y) {
        return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) > 0;
    }
    friend bool operator>=(const biguint& x, const biguint& y) {
        return arith::cmp(x.buf.begin(), x.buf.end(), y.buf.begin(), y.buf.end()) >= 0;
    }
    
    friend std::istream& operator>>(std::istream&, biguint&);
    friend std::ostream& operator<<(std::ostream&, biguint);
};
 
std::istream& operator>>(std::istream& is, biguint& x) {	
    std::string s; is >> s;
    x.buf.clear();
    for (int i=0; i<s.size(); ++i) {
        arith::mul(x.buf, 10, x.buf);
        arith::add(x.buf, s[i]-'0', x.buf);
    }
    return is;
}
 
std::ostream& operator<<(std::ostream& os, biguint x) {
    std::string s;
    while (!x.buf.empty()) {
        uint q = arith::div(x.buf, 10, x.buf);
        s += q+'0';
    }
    if (s.empty()) s += '0';
    std::reverse(s.begin(), s.end());
    return os << s;
}
 
const biguint zero(0), one(1), two(2);
 
biguint nwd(biguint a, biguint b) { return b > 0 ? nwd(b, a % b) : a; }
 
struct liczba
{
	biguint l, m;
	liczba(): l(0), m(1) {}
	liczba(biguint a): l(a), m(1) {}
	liczba(biguint a, biguint b): l(a), m(b) {}	
	liczba operator*(const liczba &L) const
	{
		liczba tmp;
		tmp.l = l * L.l;
		tmp.m = m * L.m;		
		return tmp;
	}
	liczba operator/(const liczba &L) const
	{
		liczba tmp;
		tmp.l = l * L.m;
		tmp.m = m * L.l;		
		return tmp;
	}
	liczba operator+(const liczba &L) const
	{
		liczba tmp;
		tmp.m = m*L.m;
		tmp.l = L.m * l + m * L.l;		
		return tmp;
	}
	liczba operator-(const liczba &L) const
	{
		liczba tmp;
		tmp.m = m*L.m;
		tmp.l = L.m * l - m * L.l;		
		return tmp;
	}	
	void normalize()
	{
		biguint d = nwd(l, m);
		l /= d;
		m /= d;
	}
};
 
#define MR 151
 
liczba t[MR];
 
biguint sil[MR], sil1[MR], sil2[MR];
liczba sum[MR], dod[MR];
 
inline void F(int n)
{	
	if(n > 3)
	{
		dod[n] = dod[n-1] + (liczba)sil1[n-2]*((liczba)1+t[n-2]);
		dod[n].normalize();
		sum[n] = sum[n-1] + (liczba)(2*sil1[n-1])*((liczba)1+t[n-1])+dod[n];
		sum[n].normalize();
	}
	t[n] = ((liczba)(1+sil1[n])+sum[n])/(liczba)sil2[n-1];	
	t[n].normalize();
}//F
 
int main()
{	
	sil[0] = 1;
	for(int i = 1; i < MR; i++)
		sil[i] = sil[i-1]*i;
	for(int i = 2; i < MR; i++)
		sil1[i] = sil[i]-2*sil[i-1]+sil[i-2];
	for(int i = 1; i < MR; i++)
		sil2[i] = 2*sil[i]-sil[i-1];
	t[2] = (liczba)2;
	sum[3] = (liczba)6;	//dod[3] = 0	
	for(int i = 3; i < MR; i++)
		F(i);		
	int tests;
	cin >> tests;
	for(int c = 0; c < tests; c++)
	{
		int n;
		cin >> n;		
		if(n != 2 && n != 4)
			cout << t[n].l << "/" << t[n].m << "
";
		else if(n == 2)
			cout << "2
";
		else
			cout << "5
";
	}
	return 0;
}