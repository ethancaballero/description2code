#include<bits/stdc++.h>
#define intMAX 1123456789LL
#define MAX intMAX * intMAX
#define F first
#define S second
#define mp make_pair
#define ll long long
#define pb push_back
#define pv(v,b,a) v.insert(v.begin()+b,a)
#define all(c) c.begin(),c.end()
#define sf(a) scanf("%d",&a);
#define sl(a) scanf("%lld",&a);
#define MAXCR 1000000000
#define mem(arr,a) memset(arr, a, sizeof arr)
#define er(vec,a,b) vec.erase(vec.begin() + a, vec.begin() + b+1)
#define traverse(a) for()
#define pii pair<int ,int>
#define mod 1000000007
#define LIM 100
using namespace std;
/*
list as pop_front();push_front(ELEMENT);
list as pop_front();push_back(ELEMENT);
to see first element stack=q.front()
to see last element queue=q.back()
*/
//str.insert(6,str3,3,4); to insert 4 words from str3 starting from 3rd position(0 based indexing) to str from 6th position (0 based indexing)
//str.find("live");//finds first occurance of string and returns its 0 based indes
//string str1=str.substr (a,n);//a=0 based start index,n=length of words//if length not given substring till end is formed
//auto bound_=upper_bound (v.begin(), v.end(), 20); //Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.
//auto bound_=lower_bound (v.begin(), v.end(), 20);//Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.
//bool ans=binary_search();//Returns true if any element in the range [first,last) is equivalent to val, and false otherwise.
/*
//for(???<???>:iterator itr;itr!=???.end();itr++) or for(auto &tt : t.edges)
map<double,LL>my;
map<double,LL>:: iterator it;
for(it=my.begin();it!=my.end();it++)
*/
//getline(cin,s,'
');  to get input terminating at'
';excluding '
'
//(a/b)%m = ((a%m)(b^(m-2)%m))%m.
//(a^b)%m=
//vector<ll>v(size,default val);
//reverse(all(s))//to reverse some vector or string;
//cin.eof() //checks for end of file return true when cin takes input as end of file
vector<int>gp[10005];
vector<pair<int,int> >hash_(100005);
int flag,time_,visited1[100005],visited2[100005],node[100005];
void pre()
{
	int i;
	flag=0;
	for(i=0;i<10005;i++)
	{
		gp[i].clear();
		hash_[i].F=-1;
		hash_[i].S=-1;
		visited1[i]=0;
		visited2[i]=0;
		node[100005]=0;
	}
	time_=1;
}
void cycle(int v)
{
	if(flag==1||visited1[v]==1)
		return ;
	int i;
	hash_[v].F=time_++;
	visited1[v]=1;
	for(i=0;i<gp[v].size();i++)
	{
		int u=gp[v][i];
		int intime=hash_[u].F;
		int outtime=hash_[u].S;
		if(intime!=-1&&outtime==-1)
		{
			flag=1;
			return ;
		}
		if(visited1[u]==0)
			cycle(u);
	}
	hash_[v].S=time_++;
}
int dfs(int v)
{
	int ans=1,i;
	visited2[v]=1;
	for(i=0;i<gp[v].size();i++)
	{
		int u=gp[v][i];
		if(visited2[u]==0)
		{
			ans=max(ans,dfs(u)+1);
		}
		else
		{
			ans=max(ans,node[u]+1);
		}
	}
	node[v]=ans;
	return ans;
}

int main()
{
	int t,n,m,i,a,b;
	sf(t)
	while(t--)
	{
		pre();
		sf(n)
		sf(m)
		for(i=0;i<m;i++)
		{
			sf(a)
			sf(b)
			gp[a].pb(b);
		}
		for(i=1;i<=n;i++)
		{
			cycle(i);
		}
		if(flag==1)
		{
			printf("IMPOSSIBLE
");
			continue;
		}
		int ans=1;
		for(i=1;i<=n;i++)
		{
			if(visited2[i]==0)
				ans=max(ans,dfs(i));
		}
		printf("%d
",ans);
	}
	return 0;
}
